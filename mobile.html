<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
  <title>DEVIN FEILEN - Mobile</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Courier New', monospace;
      background: #fafafa;
      overflow: hidden;
      width: 100%;
      height: 100vh;
    }

    #category-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100vh;
      background: #fff;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
      z-index: 5000;
      gap: 18px;
      opacity: 1;
      transition: opacity 0.8s ease;
      padding-top: 80px;
    }

    #category-screen.fade-out {
      opacity: 0;
    }

    #category-screen.hidden {
      display: none;
    }

    #category-screen h1 {
      font-family: 'VT323', monospace;
      font-weight: 400;
      font-size: 56px;
      margin-bottom: 50px;
      letter-spacing: 2px;
      line-height: 0.9;
      text-align: center;
      text-transform: uppercase;
    }

    .category-btn {
      padding: 10px 28px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica', 'Arial', sans-serif;
      font-weight: 600;
      font-size: 15px;
      background: transparent;
      color: #000;
      border: 2px solid #000;
      cursor: pointer;
      border-radius: 30px;
      transition: all 0.3s ease;
      min-width: 160px;
      text-decoration: none;
      display: inline-block;
      text-align: center;
      box-sizing: border-box;
      line-height: 1.5;
    }

    .category-btn:active {
      background: #000;
      color: #fff;
      transform: scale(0.98);
    }

    body.category-view {
      overflow: hidden;
    }

    body.category-view #back-btn,
    body.category-view #background-text,
    body.category-view #results-viewport,
    body.category-view #results,
    body.category-view #loading,
    body.category-view #pan-instructions {
      display: none;
    }

    #results {
      width: 200vw;
      height: 200vh;
      position: absolute;
      top: 0;
      left: 0;
      background: #fafafa;
      opacity: 0;
      transition: opacity 0.5s ease;
      touch-action: none;
      will-change: transform;
      transform: translateZ(0);
    }

    #results-viewport {
      width: 100%;
      height: 100vh;
      position: fixed;
      top: 0;
      left: 0;
      overflow: hidden;
      background: #fafafa;
      z-index: 5;
    }

    #results.fade-in {
      opacity: 1;
    }

    .image-wrapper {
      position: absolute;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.3s ease;
      cursor: pointer;
      transform: translateZ(0);
      will-change: transform;
    }

    #results img {
      position: relative;
      cursor: pointer;
      pointer-events: auto;
      display: block;
      border-radius: 4px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      opacity: 0;
      animation: fadeIn 0.5s ease forwards;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    @keyframes fadeIn {
      to { opacity: 1; }
    }

    #pan-instructions {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.75);
      color: white;
      padding: 10px 20px;
      border-radius: 20px;
      font-size: 13px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica', 'Arial', sans-serif;
      z-index: 1500;
      opacity: 1;
      transition: opacity 0.5s ease;
      pointer-events: none;
    }

    #pan-instructions.hidden {
      opacity: 0;
    }

    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 1000;
    }

    #loading-spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #000;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 0 auto 10px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    #back-btn {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 2000;
      padding: 10px 18px;
      font-size: 15px;
      border-radius: 20px;
      background: rgba(0, 0, 0, 0.85);
      color: white;
      border: none;
      cursor: pointer;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica', 'Arial', sans-serif;
      font-weight: 600;
      display: none;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    #back-btn:active {
      background: rgba(0, 0, 0, 0.95);
    }

    body:not(.category-view) #back-btn {
      display: block;
    }

    #background-text {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: 'VT323', monospace;
      font-size: 120px;
      font-weight: 400;
      color: #e8e8e8;
      text-transform: uppercase;
      letter-spacing: 8px;
      line-height: 1.2;
      text-align: center;
      z-index: 0;
      pointer-events: none;
      user-select: none;
      white-space: nowrap;
    }

    #lightbox {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      z-index: 10000;
      justify-content: center;
      align-items: center;
    }

    #lightbox img {
      max-width: 90vw;
      max-height: 90vh;
      width: auto;
      height: auto;
      object-fit: contain;
    }

    #lightbox-close {
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 40px;
      color: white;
      cursor: pointer;
      background: none;
      border: none;
      padding: 10px;
      line-height: 1;
      z-index: 10001;
    }

    @media (max-width: 768px) {
      #background-text {
        font-size: 80px;
        letter-spacing: 4px;
      }
    }

    @media (max-width: 480px) {
      #background-text {
        font-size: 60px;
        letter-spacing: 2px;
      }
    }
  </style>
</head>
<body class="category-view">
  <div id="category-screen">
    <h1>DEVIN<br>FEILEN</h1>
    <button class="category-btn" data-category="cycling">Cycling</button>
    <button class="category-btn" data-category="life">Life</button>
    <a href="about.html" class="category-btn">About</a>
  </div>

  <button id="back-btn" aria-label="Back to categories">← Back</button>
  <div id="background-text">DEVIN<br>FEILEN</div>

  <div id="loading" role="status" aria-live="polite">
    <div id="loading-spinner" aria-hidden="true"></div>
    <p>Loading photos...</p>
  </div>

  <div id="results-viewport">
    <div id="results" role="main" aria-label="Photo gallery"></div>
  </div>

  <div id="pan-instructions">Drag to explore • Pinch to zoom • Zoom in to see more photos</div>

  <div id="lightbox" role="dialog" aria-labelledby="lightbox-img" aria-modal="true">
    <button id="lightbox-close" aria-label="Close fullscreen view">&times;</button>
    <img id="lightbox-img" alt="" />
  </div>

  <script>
    let allPhotos = [];
    let photoQueue = [];
    let loadedCount = 0;
    let isLoadingMore = false;
    let currentCategory = null;

    // Pan and zoom state
    let scale = 1;
    let minScale = 0.5;
    let maxScale = 3;
    let posX = 0;
    let posY = 0;
    let lastPosX = 0;
    let lastPosY = 0;
    let isDragging = false;
    let startX = 0;
    let startY = 0;
    
    // Pinch zoom
    let initialDistance = 0;
    let initialScale = 1;

    const canvas = {
      width: window.innerWidth * 2,  // Start smaller (2x instead of 3x)
      height: window.innerHeight * 2
    };

    // Track placed images for collision detection
    let placedImages = [];
    
    // Spatial grid for fast collision detection
    const gridCellSize = 300;
    let spatialGrid = {};
    
    // Zoom-based loading
    let lastLoadZoomLevel = 1;
    let imagesPerZoomLevel = 30;
    
    // Performance optimization
    let animationFrameId = null;
    let isTransformPending = false;

    document.addEventListener('DOMContentLoaded', () => {
      const categoryButtons = document.querySelectorAll('.category-btn');
      
      categoryButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          const category = btn.dataset.category;
          if (category) {
            loadCategory(category);
          }
        });
      });

      const backBtn = document.getElementById("back-btn");
      if (backBtn) {
        backBtn.addEventListener('click', backToCategories);
      }
    });

    function loadCategory(category) {
      currentCategory = category;
      
      const categoryScreen = document.getElementById('category-screen');
      categoryScreen.classList.add('fade-out');
      
      setTimeout(() => {
        categoryScreen.classList.add('hidden');
        document.body.classList.remove('category-view');
        
        document.getElementById("loading").style.display = "block";
        
        let jsonFile = 'photos.json';
        if (category === 'cycling') jsonFile = 'cycling.json';
        else if (category === 'life') jsonFile = 'life.json';
        
        fetch(jsonFile)
          .then(res => res.json())
          .then(data => {
            allPhotos = data;
            resetQueue();
            loadInitialPhotos();
            
            setTimeout(() => {
              document.getElementById('results').classList.add('fade-in');
            }, 100);
          })
          .catch(err => {
            document.getElementById("loading").innerHTML = `<p>Error loading ${category} photos. Please refresh the page.</p>`;
          });
      }, 800);
    }

    function backToCategories() {
      const resultsDiv = document.getElementById('results');
      
      resultsDiv.classList.remove('fade-in');
      
      setTimeout(() => {
        resultsDiv.innerHTML = '';
        loadedCount = 0;
        scale = 1;
        posX = 0;
        posY = 0;
        placedImages = [];
        spatialGrid = {};
        lastLoadZoomLevel = 1;
        
        // Reset canvas size
        canvas.width = window.innerWidth * 2;
        canvas.height = window.innerHeight * 2;
        
        const categoryScreen = document.getElementById('category-screen');
        categoryScreen.classList.remove('fade-out');
        categoryScreen.classList.remove('hidden');
        document.body.classList.add('category-view');
      }, 500);
    }

    function resetQueue() {
      photoQueue = shuffleArray([...allPhotos]);
    }

    function getNextBatch(count) {
      if (photoQueue.length < count) {
        resetQueue();
      }
      return photoQueue.splice(0, count);
    }

    function loadInitialPhotos() {
      document.getElementById("loading").style.display = "none";
      
      // Center the canvas initially
      const resultsDiv = document.getElementById('results');
      posX = -(canvas.width - window.innerWidth) / 2;
      posY = -(canvas.height - window.innerHeight) / 2;
      updateTransform();
      
      setupPanAndZoom();
      
      // Load initial batch
      const batch = getNextBatch(30);
      addImages(batch);
      
      // Hide instructions after 5 seconds
      setTimeout(() => {
        document.getElementById('pan-instructions').classList.add('hidden');
      }, 5000);
    }

    function addImages(selected) {
      const resultsDiv = document.getElementById("results");
      
      // Larger size variations (percentage of viewport width)
      const sizeVariations = [0.45, 0.55, 0.65, 0.50, 0.60, 0.48, 0.58, 0.52, 0.62, 0.46];
      
      selected.forEach((src, index) => {
        setTimeout(() => {
          const img = new Image();
          img.src = src;
          img.alt = `Photography by Devin Feilen`;
          img.loading = "eager";

          img.onload = () => {
            loadedCount++;

            const wrapper = document.createElement('div');
            wrapper.className = 'image-wrapper';
            
            // Random larger size
            const sizePercent = sizeVariations[loadedCount % sizeVariations.length];
            const size = window.innerWidth * sizePercent;
            
            // Calculate dimensions maintaining aspect ratio
            const aspectRatio = img.naturalWidth / img.naturalHeight;
            let width, height;
            
            if (aspectRatio > 1) {
              // Landscape
              width = size;
              height = size / aspectRatio;
            } else {
              // Portrait
              height = size;
              width = size * aspectRatio;
            }
            
            // Find position with NO overlap using spatial grid
            const position = findBestPositionOptimized(width, height);
            
            if (!position) {
              return; // Skip this image if can't place
            }
            
            wrapper.style.left = position.x + "px";
            wrapper.style.top = position.y + "px";
            wrapper.style.width = width + "px";
            wrapper.style.height = height + "px";
            wrapper.style.zIndex = loadedCount;
            
            img.style.width = width + "px";
            img.style.height = height + "px";
            
            // Store in placedImages and spatial grid
            const imageData = {
              x: position.x,
              y: position.y,
              width: width,
              height: height,
              element: wrapper
            };
            
            placedImages.push(imageData);
            addToSpatialGrid(imageData);
            
            wrapper.appendChild(img);
            makeExpandable(img);
            resultsDiv.appendChild(wrapper);
          };

          img.onerror = (e) => {
            img.dataset.retryCount = img.dataset.retryCount ? parseInt(img.dataset.retryCount) + 1 : 1;
            
            if (img.dataset.retryCount <= 2) {
              const retryDelay = img.dataset.retryCount * 3000;
              
              setTimeout(() => {
                const timestamp = new Date().getTime();
                img.src = src + '?t=' + timestamp;
              }, retryDelay);
            }
          };
        }, index * 50); // Reduced from 100ms for faster loading
      });
    }

    // Spatial grid functions for fast collision detection
    function getGridKey(x, y) {
      const gridX = Math.floor(x / gridCellSize);
      const gridY = Math.floor(y / gridCellSize);
      return `${gridX},${gridY}`;
    }
    
    function addToSpatialGrid(imageData) {
      // Add image to all grid cells it overlaps
      const minX = Math.floor(imageData.x / gridCellSize);
      const maxX = Math.floor((imageData.x + imageData.width) / gridCellSize);
      const minY = Math.floor(imageData.y / gridCellSize);
      const maxY = Math.floor((imageData.y + imageData.height) / gridCellSize);
      
      for (let gx = minX; gx <= maxX; gx++) {
        for (let gy = minY; gy <= maxY; gy++) {
          const key = `${gx},${gy}`;
          if (!spatialGrid[key]) {
            spatialGrid[key] = [];
          }
          spatialGrid[key].push(imageData);
        }
      }
    }
    
    function getNearbyImages(x, y, width, height) {
      const minX = Math.floor(x / gridCellSize);
      const maxX = Math.floor((x + width) / gridCellSize);
      const minY = Math.floor(y / gridCellSize);
      const maxY = Math.floor((y + height) / gridCellSize);
      
      const nearbyImages = new Set();
      
      for (let gx = minX; gx <= maxX; gx++) {
        for (let gy = minY; gy <= maxY; gy++) {
          const key = `${gx},${gy}`;
          if (spatialGrid[key]) {
            spatialGrid[key].forEach(img => nearbyImages.add(img));
          }
        }
      }
      
      return Array.from(nearbyImages);
    }

    function findBestPositionOptimized(width, height) {
      const padding = 30;
      const maxX = canvas.width - width - padding;
      const maxY = canvas.height - height - padding;
      const maxAttempts = 20; // Reduced from 50 for performance
      
      for (let attempt = 0; attempt < maxAttempts; attempt++) {
        let x, y;
        
        if (attempt < 10) {
          // Grid-based positioning
          const cols = 6;
          const rows = 6;
          const cellWidth = canvas.width / cols;
          const cellHeight = canvas.height / rows;
          
          const col = Math.floor(Math.random() * cols);
          const row = Math.floor(Math.random() * rows);
          
          x = col * cellWidth + Math.random() * (cellWidth - width);
          y = row * cellHeight + Math.random() * (cellHeight - height);
        } else {
          // Random positioning
          x = padding + Math.random() * maxX;
          y = padding + Math.random() * maxY;
        }
        
        x = Math.max(padding, Math.min(x, maxX));
        y = Math.max(padding, Math.min(y, maxY));
        
        // Only check nearby images using spatial grid
        if (!hasOverlapOptimized(x, y, width, height)) {
          return { x, y };
        }
      }
      
      return null;
    }

    function hasOverlapOptimized(x, y, width, height) {
      const nearbyImages = getNearbyImages(x, y, width, height);
      
      for (const placed of nearbyImages) {
        if (rectanglesOverlap(
          x, y, width, height,
          placed.x, placed.y, placed.width, placed.height
        )) {
          return true;
        }
      }
      return false;
    }

    function rectanglesOverlap(x1, y1, w1, h1, x2, y2, w2, h2) {
      return !(x1 + w1 <= x2 || x2 + w2 <= x1 || y1 + h1 <= y2 || y2 + h2 <= y1);
    }

    function setupPanAndZoom() {
      const resultsDiv = document.getElementById('results');
      const viewport = document.getElementById('results-viewport');
      
      let lastTouchX = 0;
      let lastTouchY = 0;
      let pinchCenterX = 0;
      let pinchCenterY = 0;
      
      // Touch start
      viewport.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1) {
          // Single touch - pan
          isDragging = true;
          startX = e.touches[0].clientX - posX;
          startY = e.touches[0].clientY - posY;
          lastTouchX = e.touches[0].clientX;
          lastTouchY = e.touches[0].clientY;
        } else if (e.touches.length === 2) {
          // Two fingers - pinch zoom
          isDragging = false;
          
          // Calculate pinch center point
          pinchCenterX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
          pinchCenterY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
          
          initialDistance = getDistance(e.touches[0], e.touches[1]);
          initialScale = scale;
        }
      }, { passive: true });
      
      // Touch move
      viewport.addEventListener('touchmove', (e) => {
        if (e.touches.length === 1 && isDragging) {
          // Pan
          posX = e.touches[0].clientX - startX;
          posY = e.touches[0].clientY - startY;
          
          // Request update on next animation frame
          requestTransformUpdate();
        } else if (e.touches.length === 2) {
          // Pinch zoom
          e.preventDefault();
          
          const currentDistance = getDistance(e.touches[0], e.touches[1]);
          const newScale = initialScale * (currentDistance / initialDistance);
          
          // Calculate new pinch center
          const currentPinchCenterX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
          const currentPinchCenterY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
          
          // Constrain zoom
          const constrainedScale = Math.max(minScale, Math.min(maxScale, newScale));
          
          // Calculate zoom adjustment to keep pinch center fixed
          const scaleChange = constrainedScale / scale;
          
          // Adjust position to zoom towards pinch center
          const deltaX = currentPinchCenterX - posX;
          const deltaY = currentPinchCenterY - posY;
          
          posX = currentPinchCenterX - deltaX * scaleChange;
          posY = currentPinchCenterY - deltaY * scaleChange;
          
          scale = constrainedScale;
          
          // Request update on next animation frame
          requestTransformUpdate();
        }
      }, { passive: false });
      
      // Touch end
      viewport.addEventListener('touchend', (e) => {
        if (e.touches.length < 2) {
          isDragging = false;
          initialDistance = 0;
          
          // Check if we should load more images based on zoom level
          checkZoomBasedLoading();
        }
        if (e.touches.length === 1) {
          // Continue panning with remaining finger
          isDragging = true;
          startX = e.touches[0].clientX - posX;
          startY = e.touches[0].clientY - posY;
        }
      }, { passive: true });
    }
    
    function requestTransformUpdate() {
      if (!isTransformPending) {
        isTransformPending = true;
        
        if (animationFrameId) {
          cancelAnimationFrame(animationFrameId);
        }
        
        animationFrameId = requestAnimationFrame(() => {
          constrainPan();
          updateTransform();
          isTransformPending = false;
        });
      }
    }
    
    function checkZoomBasedLoading() {
      // Load more images when zooming in past certain thresholds
      const zoomThresholds = [1.2, 1.5, 1.8, 2.1, 2.4, 2.7, 3.0];
      
      for (const threshold of zoomThresholds) {
        if (scale >= threshold && lastLoadZoomLevel < threshold && photoQueue.length > 0) {
          lastLoadZoomLevel = threshold;
          
          // Load more images - more detail at higher zoom
          const batchSize = Math.floor(imagesPerZoomLevel * (scale / threshold));
          const batch = getNextBatch(Math.min(batchSize, photoQueue.length));
          
          if (batch.length > 0) {
            addImages(batch);
          }
          
          break;
        }
      }
    }
    
    function getDistance(touch1, touch2) {
      const dx = touch1.clientX - touch2.clientX;
      const dy = touch1.clientY - touch2.clientY;
      return Math.sqrt(dx * dx + dy * dy);
    }
    
    function constrainPan() {
      const scaledWidth = canvas.width * scale;
      const scaledHeight = canvas.height * scale;
      
      const minX = window.innerWidth - scaledWidth;
      const minY = window.innerHeight - scaledHeight;
      
      posX = Math.max(Math.min(posX, 0), minX);
      posY = Math.max(Math.min(posY, 0), minY);
    }
    
    function updateTransform() {
      const resultsDiv = document.getElementById('results');
      resultsDiv.style.transform = `translate3d(${posX}px, ${posY}px, 0) scale(${scale})`;
      resultsDiv.style.transformOrigin = '0 0';
    }

    function loadMoreMobileImages() {
      // Manual load more (if needed for fallback)
      if (isLoadingMore || photoQueue.length === 0) return;
      
      isLoadingMore = true;
      
      const batch = getNextBatch(10);
      addImages(batch);
      
      setTimeout(() => { 
        isLoadingMore = false; 
      }, 500);
    }

    function makeExpandable(img) {
      const lightbox = document.getElementById("lightbox");
      const lightboxImg = document.getElementById("lightbox-img");
      const lightboxClose = document.getElementById("lightbox-close");
      
      let touchStartTime = 0;
      let touchStartPos = { x: 0, y: 0 };
      
      img.addEventListener('touchstart', (e) => {
        touchStartTime = Date.now();
        touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      }, { passive: true });
      
      img.addEventListener('touchend', (e) => {
        const touchEndTime = Date.now();
        const touchEndPos = { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
        
        // Calculate distance moved
        const distance = Math.sqrt(
          Math.pow(touchEndPos.x - touchStartPos.x, 2) + 
          Math.pow(touchEndPos.y - touchStartPos.y, 2)
        );
        
        // Only open lightbox if it was a tap (short duration, minimal movement)
        if (touchEndTime - touchStartTime < 300 && distance < 10) {
          lightboxImg.src = img.src;
          lightboxImg.alt = img.alt;
          lightbox.style.display = "flex";
        }
      }, { passive: true });

      lightboxClose.addEventListener("click", () => {
        lightbox.style.display = "none";
      });

      lightbox.addEventListener("click", e => {
        if (e.target === lightbox || e.target === lightboxImg) {
          lightbox.style.display = "none";
        }
      });
    }

    function shuffleArray(array) {
      return array.map(v => ({v, sort: Math.random()}))
        .sort((a, b) => a.sort - b.sort)
        .map(({v}) => v);
    }
  </script>
</body>
</html>
