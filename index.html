<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Devin Feilen</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg: #f5f5f3;
      --text: #111;
      --text-muted: #888;
      --border: #ddd;
    }

    html, body {
      height: 100%;
      overflow: hidden;
    }

    body {
      font-family: 'Space Mono', monospace;
      background: var(--bg);
      color: var(--text);
    }

    /* Navigation */
    .nav {
      position: fixed;
      top: 24px;
      left: 32px;
      z-index: 100;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 12px;
      font-size: 12px;
      letter-spacing: 0.05em;
    }

    .category-btn {
      background: none;
      border: none;
      font-family: inherit;
      font-size: inherit;
      letter-spacing: inherit;
      color: var(--text);
      cursor: pointer;
      text-transform: uppercase;
      padding: 0;
      text-decoration: none;
      position: relative;
    }

    .category-btn span {
      display: inline-block;
      transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    .category-btn:hover span:nth-child(1) { transform: translate(-6px, -10px) rotate(-15deg); }
    .category-btn:hover span:nth-child(2) { transform: translate(3px, -12px) rotate(12deg); }
    .category-btn:hover span:nth-child(3) { transform: translate(-2px, 8px) rotate(-8deg); }
    .category-btn:hover span:nth-child(4) { transform: translate(5px, -6px) rotate(18deg); }
    .category-btn:hover span:nth-child(5) { transform: translate(-4px, 10px) rotate(-12deg); }
    .category-btn:hover span:nth-child(6) { transform: translate(6px, -4px) rotate(8deg); }

    .category-btn:hover {
      text-decoration: none;
    }

    .category-btn.active {
      text-decoration: underline;
    }

    /* Refresh Button */
    .refresh-btn {
      position: fixed;
      bottom: 24px;
      right: 32px;
      z-index: 100;
      background: none;
      border: none;
      font-family: inherit;
      font-size: 12px;
      letter-spacing: 0.05em;
      color: var(--text);
      cursor: pointer;
      text-transform: uppercase;
      padding: 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .refresh-btn:hover {
      text-decoration: underline;
    }

    .refresh-exclaim {
      font-weight: bold;
      animation: pulse 1s ease-in-out infinite;
    }

    .refresh-exclaim.hidden {
      display: none;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    /* Popup Notice */
    .popup-notice {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 11px;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: var(--text-muted);
      z-index: 100;
      opacity: 0;
      transition: opacity 0.5s ease;
      pointer-events: none;
    }

    .popup-notice.visible {
      opacity: 1;
    }

    /* A&B Link - Floating Badge */
    .ab-link {
      position: fixed;
      bottom: 32px;
      left: 32px;
      font-size: 12px;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: var(--text);
      text-decoration: none;
      z-index: 100;
      opacity: 0;
      transition: opacity 0.5s ease;
      pointer-events: none;
      background: var(--bg);
      padding: 12px 16px;
      border: 2px solid var(--text);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .ab-link.visible {
      opacity: 1;
      pointer-events: auto;
      animation: badgePulse 2s ease-in-out infinite;
    }

    .ab-link-arrow {
      display: inline-block;
      animation: arrowBounce 1s ease-in-out infinite;
    }

    @keyframes badgePulse {
      0%, 100% { box-shadow: 0 0 0 0 rgba(26, 26, 26, 0.2); }
      50% { box-shadow: 0 0 0 8px rgba(26, 26, 26, 0); }
    }

    @keyframes arrowBounce {
      0%, 100% { transform: translateX(0); }
      50% { transform: translateX(5px); }
    }

    /* About Box */
    .about-box {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 90%;
      max-width: 500px;
      background: var(--bg);
      padding: 40px;
      z-index: 60;
      opacity: 0;
      transition: opacity 0.5s ease;
      pointer-events: none;
    }

    .about-box.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .about-box h2 {
      font-size: 14px;
      font-weight: 700;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      margin-bottom: 24px;
    }

    .about-box p {
      font-size: 13px;
      line-height: 1.8;
      margin-bottom: 16px;
      color: var(--text);
    }

    .about-box a {
      color: var(--text);
      text-decoration: underline;
    }

    .about-box a:hover {
      color: var(--text-muted);
    }

    /* Canvas Area */
    .canvas {
      position: fixed;
      inset: 0;
      overflow: hidden;
    }

    /* Floating Images */
    .float-img {
      position: absolute;
      opacity: 0;
      transform: scale(0.9);
      transition: opacity 0.5s ease, transform 0.5s ease;
      pointer-events: auto;
      cursor: grab;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1);
      touch-action: none; /* Prevent browser gestures on touch */
    }

    .float-img.visible {
      opacity: 1;
      transform: scale(1);
    }

    .float-img.dragging {
      cursor: grabbing;
      transition: none;
    }

    .float-img img {
      display: block;
      height: auto;
      max-width: 100%;
      pointer-events: none;
      user-select: none;
      -webkit-user-drag: none;
    }

    .float-img:hover {
      z-index: 50 !important;
    }

    /* Resize Handle */
    .resize-handle {
      position: absolute;
      bottom: -6px;
      right: -6px;
      width: 12px;
      height: 12px;
      background: var(--text);
      border: 2px solid var(--bg);
      border-radius: 50%;
      cursor: nwse-resize;
      opacity: 0;
      transition: opacity 0.2s ease;
      z-index: 10;
    }

    .float-img:hover .resize-handle {
      opacity: 1;
    }

    .resize-handle:hover {
      transform: scale(1.2);
    }

    /* Show resize handle on touch devices (coarse pointer = finger) */
    @media (pointer: coarse) {
      .resize-handle {
        opacity: 0.6;
        width: 16px;
        height: 16px;
        bottom: -8px;
        right: -8px;
      }
      
      .float-img:active .resize-handle {
        opacity: 1;
      }
    }

    /* Loading */
    .loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 50;
      opacity: 1;
      transition: opacity 0.4s ease;
    }

    .loading.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .loading-text {
      font-size: 11px;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    /* Lightbox */
    .lightbox {
      position: fixed;
      inset: 0;
      background: var(--bg);
      z-index: 1000;
      display: none;
      flex-direction: column;
      opacity: 0;
      transition: opacity 0.4s ease;
    }

    .lightbox.active {
      display: flex;
    }

    .lightbox.visible {
      opacity: 1;
    }

    .lightbox-header {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      padding: 24px 32px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 10;
    }

    .lightbox-counter {
      font-size: 11px;
      letter-spacing: 0.05em;
      color: var(--text-muted);
      text-transform: uppercase;
    }

    .lightbox-close {
      font-size: 11px;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      background: none;
      border: 1px solid var(--border);
      padding: 10px 20px;
      cursor: pointer;
      font-family: inherit;
      color: var(--text);
      transition: all 0.2s ease;
    }

    .lightbox-close:hover {
      border-color: var(--text);
      background: var(--text);
      color: var(--bg);
    }

    /* Larger touch targets on touch devices */
    @media (pointer: coarse) {
      .lightbox-close {
        padding: 14px 28px;
        font-size: 12px;
      }
      
      .lightbox-nav {
        width: 56px;
        height: 56px;
      }
      
      .category-btn {
        padding: 8px 4px;
      }
    }

    .lightbox-content {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 80px 100px;
    }

    .lightbox-content img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      opacity: 0;
      transform: translateY(10px);
      transition: all 0.4s ease;
    }

    .lightbox.visible .lightbox-content img {
      opacity: 1;
      transform: translateY(0);
    }

    .lightbox-nav {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      background: none;
      border: 1px solid var(--border);
      width: 48px;
      height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .lightbox-nav:hover {
      border-color: var(--text);
      background: var(--text);
    }

    .lightbox-nav:hover svg {
      stroke: var(--bg);
    }

    .lightbox-nav svg {
      width: 20px;
      height: 20px;
      stroke: var(--text);
      stroke-width: 1.5;
      fill: none;
    }

    .lightbox-prev {
      left: 32px;
    }

    .lightbox-next {
      right: 32px;
    }

    /* Hide scroll hint on desktop */
    .scroll-hint {
      display: none;
    }

    /* Mobile Styles */
    @media (max-width: 768px) {
      html, body {
        height: 100%;
        overflow: hidden;
      }

      .nav {
        top: 20px;
        left: auto;
        right: 20px;
        flex-direction: column;
        align-items: flex-end;
        gap: 12px;
        font-size: 11px;
      }

      .category-btn:hover span {
        transform: none !important;
      }

      .category-btn:hover {
        text-decoration: underline;
      }

      .refresh-btn {
        display: none;
      }

      .popup-notice {
        display: none;
      }

      .ab-link {
        bottom: 24px;
        top: auto;
        left: 50%;
        transform: translateX(-50%);
        font-size: 11px;
        padding: 10px 14px;
      }

      .ab-link.visible {
        animation: badgePulse 2s ease-in-out infinite;
      }

      .canvas {
        position: fixed;
        inset: 0;
        overflow-y: auto;
        overflow-x: hidden;
        -webkit-overflow-scrolling: auto;
        overscroll-behavior: contain;
        padding: 0;
        transition: opacity 0.3s ease;
      }

      .canvas.transitioning {
        opacity: 0;
      }

      .mobile-scroll-container {
        position: relative;
        width: 100%;
        min-height: 100vh;
      }

      .float-img {
        position: absolute;
        opacity: 1;
        cursor: pointer;
        box-shadow: 0 4px 24px rgba(0,0,0,0.15);
        will-change: transform, opacity;
        border: 2px solid rgba(255,255,255,0.85);
        transition: box-shadow 0.4s ease, transform 0.3s ease;
      }

      .float-img img {
        width: 100%;
        height: auto;
        display: block;
        pointer-events: none;
        filter: blur(0);
        transition: filter 0.5s ease, transform 0.4s ease;
      }

      /* Blur-up progressive loading */
      .float-img img.loading {
        filter: blur(15px);
        transform: scale(1.02);
      }

      .float-img img.loaded {
        filter: blur(0);
        transform: scale(1);
      }

      .resize-handle {
        display: none;
      }

      .about-box {
        width: 85%;
        padding: 30px;
        max-height: 80vh;
        overflow-y: auto;
      }

      .about-box h2 {
        font-size: 13px;
        margin-bottom: 20px;
      }

      .about-box p {
        font-size: 12px;
        line-height: 1.7;
        margin-bottom: 14px;
      }

      .lightbox-content {
        padding: 60px 15px;
      }

      .lightbox-nav {
        display: none;
      }

      .lightbox-header {
        padding: 16px 20px;
      }

      .lightbox-close {
        padding: 8px 16px;
        font-size: 10px;
      }

      /* Scroll hint */
      .scroll-hint {
        position: fixed;
        bottom: 20%;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 16px;
        z-index: 50;
        opacity: 1;
        transition: opacity 0.5s ease;
        pointer-events: none;
      }

      .scroll-hint.hidden {
        opacity: 0;
      }

      .scroll-hint-arrow {
        width: 30px;
        height: 30px;
        border-right: 2px solid var(--text);
        border-top: 2px solid var(--text);
        transform: rotate(-45deg);
        animation: scrollBounce 1s ease-in-out infinite;
      }

      .scroll-hint-text {
        font-size: 13px;
        letter-spacing: 0.12em;
        text-transform: uppercase;
        color: var(--text);
      }

      @keyframes scrollBounce {
        0%, 100% { transform: translateY(0) rotate(-45deg); opacity: 1; }
        50% { transform: translateY(-12px) rotate(-45deg); opacity: 0.6; }
      }
    }
  </style>
</head>
<body>
  <!-- Navigation -->
  <nav class="nav">
    <button class="category-btn active" data-category="racing"><span>R</span><span>a</span><span>c</span><span>i</span><span>n</span><span>g</span></button>
    <button class="category-btn" data-category="bikes"><span>B</span><span>i</span><span>k</span><span>e</span><span>s</span></button>
    <button class="category-btn" data-category="life"><span>L</span><span>i</span><span>f</span><span>e</span></button>
    <button class="category-btn" data-category="walls"><span>W</span><span>a</span><span>l</span><span>l</span><span>s</span></button>
    <button class="category-btn" data-category="ab"><span>A</span><span>&</span><span>B</span></button>
    <button class="category-btn" data-category="devin"><span>D</span><span>e</span><span>v</span><span>i</span><span>n</span></button>
  </nav>

  <!-- Refresh Button (desktop only) -->
  <button class="refresh-btn" id="refresh-btn">
    <span class="refresh-exclaim" id="refresh-exclaim">!</span>
    <span>Refresh Images</span>
  </button>

  <!-- Popup Notice (desktop only) -->
  <div class="popup-notice" id="popup-notice">click drag & resize photos</div>

  <!-- A&B Link -->
  <a href="https://a-and-b.bike/" target="_blank" class="ab-link" id="ab-link">Visit a-and-b.bike <span class="ab-link-arrow">→</span></a>

  <!-- Loading -->
  <div class="loading" id="loading">
    <p class="loading-text">Loading</p>
  </div>

  <!-- Canvas -->
  <div class="canvas" id="canvas"></div>

  <!-- About Box -->
  <div class="about-box" id="about-box">
    <h2>About</h2>
    <p>Devin Feilen is a photographer based in Portland, Oregon. He can typically be found at bicycle races around the PNW or wandering around with a Ricoh GR.</p>
    <p>Site design by yours truly.</p>
    <p>You can support me at <a href="https://buymeacoffee.com/devinfeilen" target="_blank">buymeacoffee.com/devinfeilen</a></p>
    <p>For usage/licensing or any questions, please contact me via Instagram <a href="https://instagram.com/devinfeilen" target="_blank">@devinfeilen</a> or via email at <a href="/cdn-cgi/l/email-protection#b7d3d1d2d2dedbd2d9f7d0dad6dedb99d4d8da"><span class="__cf_email__" data-cfemail="c7a3a1a2a2aeaba2a987a0aaa6aeabe9a4a8aa">[email&#160;protected]</span></a></p>
    <p>Thank you for visiting :)</p>
  </div>

  <!-- Scroll Hint (mobile only) -->
  <div class="scroll-hint" id="scroll-hint">
    <div class="scroll-hint-arrow"></div>
    <span class="scroll-hint-text">Swipe up</span>
  </div>

  <!-- Lightbox -->
  <div class="lightbox" id="lightbox">
    <div class="lightbox-header">
      <span class="lightbox-counter">
        <span id="lightbox-current">01</span> / <span id="lightbox-total">00</span>
      </span>
      <button class="lightbox-close" id="lightbox-close">Close</button>
    </div>
    <button class="lightbox-nav lightbox-prev" id="lightbox-prev">
      <svg viewBox="0 0 24 24"><path d="M15 18l-6-6 6-6"/></svg>
    </button>
    <div class="lightbox-content">
      <img id="lightbox-img" alt="Photography by Devin Feilen">
    </div>
    <button class="lightbox-nav lightbox-next" id="lightbox-next">
      <svg viewBox="0 0 24 24"><path d="M9 18l6-6-6-6"/></svg>
    </button>
  </div>

  <script>
    // State
    let allPhotos = [];
    let displayedPhotos = [];
    let currentCategory = 'racing';
    let lightboxIndex = 0;
    let isMobile = window.innerWidth <= 768;
    const imageCount = 15;

    // ===== BUNNY.NET CONFIGURATION =====
    // Replace with your Bunny.net Pull Zone URL
    const BUNNY_CDN_URL = 'https://devinfeilen.b-cdn.net';

    // Mobile state
    let mobileImages = [];
    let photoQueue = [];
    let savedScrollPosition = 0; // Remember scroll position for lightbox

    // Haptic feedback helper
    function triggerHaptic(duration = 10) {
      if (navigator.vibrate) {
        navigator.vibrate(duration);
      }
    }

    // Elements
    const canvas = document.getElementById('canvas');
    const loading = document.getElementById('loading');
    const lightbox = document.getElementById('lightbox');
    const lightboxImg = document.getElementById('lightbox-img');
    const lightboxCurrent = document.getElementById('lightbox-current');
    const lightboxTotal = document.getElementById('lightbox-total');
    const scrollHint = document.getElementById('scroll-hint');
    const aboutBox = document.getElementById('about-box');
    const popupNotice = document.getElementById('popup-notice');
    const abLink = document.getElementById('ab-link');

    // Initialize
    loadCategory(currentCategory);

    // Category buttons
    document.querySelectorAll('.category-btn[data-category]').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.category-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        loadCategory(btn.dataset.category);
      });
    });

    // Refresh button (desktop only)
    const refreshExclaim = document.getElementById('refresh-exclaim');
    document.getElementById('refresh-btn').addEventListener('click', () => {
      if (!isMobile) {
        // Hide exclamation after first click
        if (refreshExclaim) {
          refreshExclaim.classList.add('hidden');
        }
        displayImages();
      }
    });

    // Lightbox controls
    document.getElementById('lightbox-close').addEventListener('click', closeLightbox);
    document.getElementById('lightbox-prev').addEventListener('click', () => navigateLightbox(-1));
    document.getElementById('lightbox-next').addEventListener('click', () => navigateLightbox(1));
    lightbox.addEventListener('click', (e) => {
      if (e.target === lightbox || e.target.closest('.lightbox-content')) {
        if (!isMobile) {
          closeLightbox();
        }
      }
    });

    // Mobile lightbox swipe gestures
    let lightboxTouchStartX = 0;
    let lightboxTouchStartY = 0;
    
    lightbox.addEventListener('touchstart', (e) => {
      lightboxTouchStartX = e.touches[0].clientX;
      lightboxTouchStartY = e.touches[0].clientY;
    }, { passive: true });
    
    lightbox.addEventListener('touchend', (e) => {
      if (!lightbox.classList.contains('active')) return;
      
      const touchEndX = e.changedTouches[0].clientX;
      const touchEndY = e.changedTouches[0].clientY;
      const deltaX = touchEndX - lightboxTouchStartX;
      const deltaY = touchEndY - lightboxTouchStartY;
      
      // Only trigger if horizontal swipe is greater than vertical
      if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 50) {
        if (deltaX > 0) {
          navigateLightbox(-1); // Swipe right = previous
        } else {
          navigateLightbox(1); // Swipe left = next
        }
      } else if (Math.abs(deltaX) < 10 && Math.abs(deltaY) < 10) {
        // Tap to close
        closeLightbox();
      }
    }, { passive: true });

    // Keyboard navigation
    document.addEventListener('keydown', (e) => {
      if (lightbox.classList.contains('active')) {
        if (e.key === 'Escape') closeLightbox();
        if (e.key === 'ArrowLeft') navigateLightbox(-1);
        if (e.key === 'ArrowRight') navigateLightbox(1);
      }
    });

    // Mobile tap to open most recently caught image
    canvas.addEventListener('click', (e) => {
      if (!isMobile) return;
      if (!canvas.mobileImageData) return;
      
      // Find the most recently caught image (highest caughtOrder)
      const imageData = canvas.mobileImageData;
      const caughtImages = imageData.filter(d => d.caught && d.wrapper.style.visibility !== 'hidden');
      if (caughtImages.length > 0) {
        caughtImages.sort((a, b) => b.caughtOrder - a.caughtOrder);
        const mostRecent = caughtImages[0];
        if (mostRecent && mostRecent.src) {
          openMobileLightbox(mostRecent.src);
        }
      }
    });

    function loadCategory(category) {
      currentCategory = category;
      
      // Smooth transition out
      canvas.classList.add('transitioning');
      
      setTimeout(() => {
        canvas.innerHTML = '';
        canvas.scrollTop = 0; // Reset scroll position on category change
        displayedPhotos = [];
        mobileImages = [];
        
        // Show/hide A&B link
        if (category === 'ab') {
          abLink.classList.add('visible');
        } else {
          abLink.classList.remove('visible');
        }
        
        // Show/hide refresh button (desktop only, not on about page)
        const refreshBtn = document.getElementById('refresh-btn');
        if (category === 'devin') {
          refreshBtn.style.display = 'none';
        } else if (!isMobile) {
          refreshBtn.style.display = 'flex';
        }
        
        // Handle about page (devin) - no photos
        if (category === 'devin') {
          aboutBox.classList.add('visible');
          loading.classList.add('hidden');
          if (isMobile && scrollHint) {
            scrollHint.classList.add('hidden');
          }
          // Transition back in
          setTimeout(() => canvas.classList.remove('transitioning'), 50);
          return;
        }
        
        // Hide about box for other categories
        aboutBox.classList.remove('visible');
        loading.classList.remove('hidden');
        
        const jsonFile = category + '.json';
        
        // Fetch category photos from static JSON file
        fetch(jsonFile)
          .then(res => {
            if (!res.ok) throw new Error('Not found');
            return res.json();
          })
          .then(data => {
            // Data can be either:
            // 1. Array of full URLs (current format)
            // 2. Array of filenames (new format - will prepend CDN URL)
            allPhotos = data.map(item => {
              // If it's already a full URL, use as-is
              if (item.startsWith('http')) {
                return item;
              }
              // Otherwise, prepend the Bunny CDN URL
              return `${BUNNY_CDN_URL}/${category}/${item}`;
            });
            
            photoQueue = shuffleArray([...allPhotos]);
            loading.classList.add('hidden');
            
            // Transition back in before displaying
            canvas.classList.remove('transitioning');
            
            setTimeout(() => {
              if (isMobile) {
                initMobileExperience();
              } else {
                displayImages();
              }
            }, 50);
          })
          .catch(err => {
            console.error('Error loading photos:', err);
            loading.classList.add('hidden');
            canvas.classList.remove('transitioning');
          });
      }, 300); // Wait for fade out
    }

    // ===== ABOUT SECTION =====
    
    function spawnAboutPhotos() {
      // Show popup notice
      showPopupNotice();
      
      // Get about box dimensions for collision avoidance
      const boxRect = aboutBox.getBoundingClientRect();
      const boxPadding = 40; // Extra padding around the box
      const excludeZone = {
        left: boxRect.left - boxPadding,
        right: boxRect.right + boxPadding,
        top: boxRect.top - boxPadding,
        bottom: boxRect.bottom + boxPadding
      };
      
      // Shuffle and pick 5 images
      const shuffled = shuffleArray([...allPhotos]);
      const selected = shuffled.slice(0, 5);
      
      // Spawn images avoiding the center
      selected.forEach((src, i) => {
        setTimeout(() => {
          spawnAboutImage(src, i, excludeZone);
        }, i * 150);
      });
    }

    function spawnAboutImage(src, index, excludeZone) {
      const wrapper = document.createElement('div');
      wrapper.className = 'float-img';
      
      const img = document.createElement('img');
      img.src = src;
      img.alt = 'Photography by Devin Feilen';
      img.loading = 'eager';
      
      // Smaller size for about page: 180-280px
      const targetWidth = 180 + Math.random() * 100;
      wrapper.style.width = targetWidth + 'px';
      
      // Add resize handle
      const resizeHandle = document.createElement('div');
      resizeHandle.className = 'resize-handle';
      wrapper.appendChild(resizeHandle);
      
      wrapper.appendChild(img);
      canvas.appendChild(wrapper);
      
      // Wait for image to load to get actual dimensions
      img.onload = () => {
        const aspectRatio = img.naturalWidth / img.naturalHeight;
        const actualHeight = targetWidth / aspectRatio;
        
        // Find position that doesn't overlap with center box
        let x, y;
        let attempts = 0;
        const padding = 60;
        
        do {
          x = padding + Math.random() * (window.innerWidth - targetWidth - padding * 2);
          y = padding + Math.random() * (window.innerHeight - actualHeight - padding * 2);
          attempts++;
        } while (
          attempts < 50 &&
          x < excludeZone.right &&
          x + targetWidth > excludeZone.left &&
          y < excludeZone.bottom &&
          y + actualHeight > excludeZone.top
        );
        
        wrapper.style.left = x + 'px';
        wrapper.style.top = y + 'px';
        wrapper.style.zIndex = index + 1;
        
        // Make draggable
        makeDraggable(wrapper);
        
        // Make resizable
        makeResizable(wrapper, img, resizeHandle);
        
        // Fade in after positioning
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            wrapper.classList.add('visible');
          });
        });
      };
      
      // Double-click to open lightbox
      wrapper.addEventListener('dblclick', () => {
        openLightbox(src);
      });
      
      displayedPhotos.push(src);
    }

    // ===== MOBILE EXPERIENCE =====
    
    function initMobileExperience() {
      canvas.innerHTML = '';
      mobileImages = [];
      displayedPhotos = [];
      
      // Show scroll hint
      if (scrollHint) {
        scrollHint.classList.remove('hidden');
      }
      
      // Create scroll container
      const scrollContainer = document.createElement('div');
      scrollContainer.className = 'mobile-scroll-container';
      scrollContainer.id = 'mobile-scroll-container';
      canvas.appendChild(scrollContainer);
      
      // Shuffle photos
      const shuffled = shuffleArray([...allPhotos]);
      
      const baseSpacing = window.innerHeight * 0.8; // Much larger spacing - 80% of screen height
      const imageData = [];
      
      // Start photos below the visible area so screen is empty initially
      let currentY = window.innerHeight + 50;
      
      shuffled.forEach((src, index) => {
        const wrapper = document.createElement('div');
        wrapper.className = 'float-img';
        
        const img = document.createElement('img');
        img.alt = 'Photography by Devin Feilen';
        
        // Random size between 55-80% of screen width
        const widthPercent = 0.55 + Math.random() * 0.25;
        const size = window.innerWidth * widthPercent;
        wrapper.style.width = size + 'px';
        
        // Random horizontal position with buffer (larger on right to avoid nav)
        const leftBuffer = 15;
        const rightBuffer = 100; // Extra buffer for nav buttons
        const maxX = window.innerWidth - size - rightBuffer;
        const x = leftBuffer + Math.random() * Math.max(0, maxX - leftBuffer);
        wrapper.style.left = x + 'px';
        
        // Position sequentially with estimated height
        const estimatedHeight = size * 0.7;
        wrapper.style.top = currentY + 'px';
        
        // Set high z-index so uncaught images appear above the pile
        wrapper.style.zIndex = 500 + index;
        
        wrapper.appendChild(img);
        scrollContainer.appendChild(wrapper);
        
        const data = {
          wrapper,
          img,
          src,
          index,
          initialY: currentY,
          initialX: x,
          estimatedHeight,
          randomOffset: Math.random() * 100 - 50,
          caught: false,
          caughtScrollPos: 0,
          caughtOrder: 0
        };
        
        imageData.push(data);
        
        // Update Y for next image
        currentY += estimatedHeight + baseSpacing + data.randomOffset;
        
        mobileImages.push(data);
        displayedPhotos.push(src);
        
        // Blur-up progressive loading
        img.classList.add('loading');
        img.loading = index < 15 ? 'eager' : 'lazy';
        img.src = src;
        
        img.onload = () => {
          img.classList.remove('loading');
          img.classList.add('loaded');
        };
      });
      
      // Store imageData reference for tap handler
      canvas.mobileImageData = imageData;
      
      // Set initial container height
      scrollContainer.style.height = (currentY + 200) + 'px';
      
      // After images load, recalculate positions
      setTimeout(() => {
        repositionMobileImages(imageData, scrollContainer, baseSpacing);
      }, 500);
      
      setTimeout(() => {
        repositionMobileImages(imageData, scrollContainer, baseSpacing);
      }, 1500);
      
      // Handle scroll for pile-up effect
      let ticking = false;
      let lastScrollTop = 0;
      
      canvas.addEventListener('scroll', () => {
        const currentScrollTop = canvas.scrollTop;
        
        if (!ticking) {
          requestAnimationFrame(() => {
            handleMobileScroll(canvas.scrollTop, imageData);
            ticking = false;
          });
          ticking = true;
        }
        
        lastScrollTop = currentScrollTop;
        
        // Hide scroll hint
        if (scrollHint && canvas.scrollTop > 20) {
          scrollHint.classList.add('hidden');
        }
      }, { passive: true });
    }
    
    function handleMobileScroll(scrollTop, imageData) {
      const maxPile = 10;
      const catchZoneY = window.innerHeight * 0.5; // Trigger point at middle of screen
      
      let caughtCount = imageData.filter(d => d.caught).length;
      
      imageData.forEach((data) => {
        if (!data.wrapper) return;
        
        // Get image height
        const imgHeight = data.wrapper.offsetHeight || data.estimatedHeight;
        const halfHeight = imgHeight / 2;
        
        // Calculate current TOP position on screen
        const currentTopY = data.initialY - scrollTop;
        
        // Calculate where CENTER of image is on screen
        const centerScreenY = currentTopY + halfHeight;
        
        if (!data.caught) {
          data.wrapper.style.zIndex = 500 + data.index;
          
          // Catch when center of image reaches catch zone
          if (centerScreenY <= catchZoneY) {
            data.caught = true;
            data.caughtScrollPos = scrollTop;
            caughtCount++;
            data.caughtOrder = caughtCount;
            
            // Haptic feedback when image catches
            triggerHaptic(15);
            
            // FREEZE at exact current screen position - no adjustment
            data.wrapper.style.position = 'fixed';
            data.wrapper.style.top = currentTopY + 'px';
            data.wrapper.style.left = data.initialX + 'px';
            data.wrapper.style.zIndex = 100 + data.caughtOrder;
            data.wrapper.style.visibility = 'visible';
            data.wrapper.style.opacity = 1;
          }
        } else {
          // Check if scrolling back up enough to uncatch
          const scrollSinceCaught = scrollTop - data.caughtScrollPos;
          
          if (scrollSinceCaught < -30) {
            data.caught = false;
            data.caughtOrder = 0;
            data.wrapper.style.position = 'absolute';
            data.wrapper.style.top = data.initialY + 'px';
            data.wrapper.style.left = data.initialX + 'px';
            data.wrapper.style.opacity = 1;
            data.wrapper.style.visibility = 'visible';
            data.wrapper.style.zIndex = 500 + data.index;
            data.wrapper.style.transform = 'scale(1)';
            data.wrapper.style.boxShadow = '0 4px 24px rgba(0,0,0,0.15)';
          }
        }
      });
      
      // Count caught images that are visible and apply visual depth
      const caughtImages = imageData.filter(d => d.caught);
      const visibleCaught = caughtImages.filter(d => d.wrapper.style.visibility !== 'hidden');
      
      // Sort by catch order for depth effects
      visibleCaught.sort((a, b) => a.caughtOrder - b.caughtOrder);
      
      // Apply scale and shadow variation based on pile position (with smooth CSS transitions)
      visibleCaught.forEach((data, idx) => {
        const pilePosition = idx / Math.max(visibleCaught.length - 1, 1); // 0 = oldest, 1 = newest
        
        // Scale: older images slightly smaller (0.92 to 1.0)
        const scale = 0.92 + (pilePosition * 0.08);
        data.wrapper.style.transform = `scale(${scale})`;
        
        // Shadow: newer images have stronger shadows (smooth transition via CSS)
        const shadowBlur = 12 + (pilePosition * 20);
        const shadowOpacity = 0.1 + (pilePosition * 0.2);
        data.wrapper.style.boxShadow = `0 ${4 + pilePosition * 8}px ${shadowBlur}px rgba(0,0,0,${shadowOpacity})`;
      });
      
      if (visibleCaught.length > maxPile) {
        // Sort by catch order (lowest = caught first)
        visibleCaught.sort((a, b) => a.caughtScrollPos - b.caughtScrollPos);
        
        // Hide oldest caught images
        const toHide = visibleCaught.slice(0, visibleCaught.length - maxPile);
        
        toHide.forEach(data => {
          data.wrapper.style.visibility = 'hidden';
        });
      }
      
      // Restore visibility for caught images that should be visible based on pile limit
      // (in case user scrolled back and pile has room)
      const hiddenCaught = caughtImages.filter(d => d.wrapper.style.visibility === 'hidden');
      if (hiddenCaught.length > 0 && visibleCaught.length < maxPile) {
        // Sort hidden by catch order (most recent first to restore)
        hiddenCaught.sort((a, b) => b.caughtScrollPos - a.caughtScrollPos);
        
        const canRestore = maxPile - visibleCaught.length;
        const toRestore = hiddenCaught.slice(0, canRestore);
        
        toRestore.forEach(data => {
          data.wrapper.style.visibility = 'visible';
        });
      }
    }
    
    function repositionMobileImages(imageData, scrollContainer, baseSpacing) {
      let yPos = window.innerHeight + 50;
      
      imageData.forEach((data) => {
        const actualHeight = data.wrapper.offsetHeight;
        const height = actualHeight > 0 ? actualHeight : data.estimatedHeight;
        
        data.initialY = yPos;
        if (!data.caught) {
          data.wrapper.style.top = yPos + 'px';
        }
        
        // Use large spacing for one-at-a-time loading feel
        yPos += height + baseSpacing + data.randomOffset;
      });
      
      scrollContainer.style.height = (yPos + 200) + 'px';
    }

    function openMobileLightbox(src) {
      // Save scroll position before opening lightbox
      savedScrollPosition = canvas.scrollTop;
      
      // Find the index in allPhotos array
      lightboxIndex = allPhotos.indexOf(src);
      if (lightboxIndex === -1) lightboxIndex = 0;
      
      lightboxImg.src = src;
      lightboxCurrent.textContent = String(lightboxIndex + 1).padStart(2, '0');
      lightboxTotal.textContent = String(allPhotos.length).padStart(2, '0');
      
      lightbox.classList.add('active');
      document.body.style.overflow = 'hidden';
      
      setTimeout(() => lightbox.classList.add('visible'), 10);
    }

    // ===== DESKTOP EXPERIENCE =====

    function displayImages() {
      // Clear existing
      canvas.innerHTML = '';
      displayedPhotos = [];
      
      // Show popup notice
      showPopupNotice();
      
      // Shuffle and pick images
      const shuffled = shuffleArray([...allPhotos]);
      const selected = shuffled.slice(0, imageCount);
      
      // Staggered reveal
      selected.forEach((src, i) => {
        setTimeout(() => {
          spawnImage(src, i);
        }, i * 120);
      });
    }
    
    function showPopupNotice() {
      if (!isMobile && popupNotice) {
        // Detect touch capability for appropriate message
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        
        if (isTouchDevice) {
          popupNotice.textContent = 'drag & resize photos • double-tap to view';
        } else {
          popupNotice.textContent = 'click drag & resize photos';
        }
        
        popupNotice.classList.add('visible');
        setTimeout(() => {
          popupNotice.classList.remove('visible');
        }, 5000);
      }
    }

    function spawnImage(src, index) {
      const wrapper = document.createElement('div');
      wrapper.className = 'float-img';
      
      const img = document.createElement('img');
      img.src = src;
      img.alt = 'Photography by Devin Feilen';
      img.loading = 'eager';
      
      // Random width between 250-400px
      const targetWidth = 250 + Math.random() * 150;
      wrapper.style.width = targetWidth + 'px';
      
      // Add resize handle
      const resizeHandle = document.createElement('div');
      resizeHandle.className = 'resize-handle';
      wrapper.appendChild(resizeHandle);
      
      wrapper.appendChild(img);
      canvas.appendChild(wrapper);
      
      // Wait for image to load to get actual dimensions
      img.onload = () => {
        const aspectRatio = img.naturalWidth / img.naturalHeight;
        const actualHeight = targetWidth / aspectRatio;
        
        // Random position with padding from edges, accounting for actual height
        const padding = 60;
        const maxX = Math.max(padding, window.innerWidth - targetWidth - padding);
        const maxY = Math.max(padding, window.innerHeight - actualHeight - padding);
        const x = padding + Math.random() * (maxX - padding);
        const y = padding + Math.random() * (maxY - padding);
        
        wrapper.style.left = x + 'px';
        wrapper.style.top = y + 'px';
        wrapper.style.zIndex = index + 1;
        
        // Make draggable
        makeDraggable(wrapper);
        
        // Make resizable
        makeResizable(wrapper, img, resizeHandle);
        
        // Fade in after positioning
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            wrapper.classList.add('visible');
          });
        });
      };
      
      // Double-click to open lightbox (mouse)
      wrapper.addEventListener('dblclick', () => {
        openLightbox(src);
      });
      
      // Double-tap to open lightbox (touch)
      let lastTapTime = 0;
      let lastTapMoved = false;
      
      wrapper.addEventListener('touchstart', () => {
        lastTapMoved = false;
      }, { passive: true });
      
      wrapper.addEventListener('touchmove', () => {
        lastTapMoved = true;
      }, { passive: true });
      
      wrapper.addEventListener('touchend', (e) => {
        // Only trigger double-tap if finger didn't move (wasn't a drag)
        if (lastTapMoved) {
          lastTapTime = 0;
          return;
        }
        
        const currentTime = new Date().getTime();
        const tapInterval = currentTime - lastTapTime;
        
        // Check if it's a double tap (within 300ms)
        if (tapInterval < 300 && tapInterval > 0) {
          e.preventDefault();
          openLightbox(src);
          lastTapTime = 0; // Reset to prevent triple-tap issues
        } else {
          lastTapTime = currentTime;
        }
      }, { passive: false });
      
      displayedPhotos.push(src);
    }

    function makeDraggable(wrapper) {
      let isDragging = false;
      let hasMoved = false;
      let startX, startY, initialLeft, initialTop;
      
      // Mouse events
      wrapper.addEventListener('mousedown', (e) => {
        // Ignore if clicking resize handle
        if (e.target.classList.contains('resize-handle')) return;
        
        isDragging = true;
        hasMoved = false;
        wrapper.classList.add('dragging');
        
        startX = e.clientX;
        startY = e.clientY;
        initialLeft = wrapper.offsetLeft;
        initialTop = wrapper.offsetTop;
        
        // Bring to front
        wrapper.style.zIndex = getMaxZIndex() + 1;
        
        e.preventDefault();
      });
      
      document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        
        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;
        
        if (Math.abs(deltaX) > 3 || Math.abs(deltaY) > 3) {
          hasMoved = true;
        }
        
        wrapper.style.left = (initialLeft + deltaX) + 'px';
        wrapper.style.top = (initialTop + deltaY) + 'px';
      });
      
      document.addEventListener('mouseup', () => {
        if (isDragging) {
          isDragging = false;
          wrapper.classList.remove('dragging');
        }
      });
      
      // Touch events for iPad/touch screens
      wrapper.addEventListener('touchstart', (e) => {
        // Ignore if touching resize handle
        if (e.target.classList.contains('resize-handle')) return;
        
        isDragging = true;
        hasMoved = false;
        wrapper.classList.add('dragging');
        
        const touch = e.touches[0];
        startX = touch.clientX;
        startY = touch.clientY;
        initialLeft = wrapper.offsetLeft;
        initialTop = wrapper.offsetTop;
        
        // Bring to front
        wrapper.style.zIndex = getMaxZIndex() + 1;
      }, { passive: true });
      
      wrapper.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        
        const touch = e.touches[0];
        const deltaX = touch.clientX - startX;
        const deltaY = touch.clientY - startY;
        
        if (Math.abs(deltaX) > 3 || Math.abs(deltaY) > 3) {
          hasMoved = true;
        }
        
        wrapper.style.left = (initialLeft + deltaX) + 'px';
        wrapper.style.top = (initialTop + deltaY) + 'px';
        
        // Prevent page scroll while dragging
        e.preventDefault();
      }, { passive: false });
      
      wrapper.addEventListener('touchend', () => {
        if (isDragging) {
          isDragging = false;
          wrapper.classList.remove('dragging');
        }
      }, { passive: true });
    }

    function makeResizable(wrapper, img, handle) {
      let isResizing = false;
      let startX, startY, startWidth, startHeight, aspectRatio;
      
      // Mouse events
      handle.addEventListener('mousedown', (e) => {
        isResizing = true;
        startX = e.clientX;
        startY = e.clientY;
        startWidth = wrapper.offsetWidth;
        startHeight = img.offsetHeight;
        aspectRatio = img.naturalWidth / img.naturalHeight;
        
        // Bring to front
        wrapper.style.zIndex = getMaxZIndex() + 1;
        
        e.preventDefault();
        e.stopPropagation();
      });
      
      document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;
        
        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;
        const delta = Math.max(deltaX, deltaY);
        
        let newWidth = startWidth + delta;
        newWidth = Math.max(100, Math.min(newWidth, window.innerWidth * 0.8));
        
        wrapper.style.width = newWidth + 'px';
      });
      
      document.addEventListener('mouseup', () => {
        isResizing = false;
      });
      
      // Touch events for iPad/touch screens
      handle.addEventListener('touchstart', (e) => {
        isResizing = true;
        const touch = e.touches[0];
        startX = touch.clientX;
        startY = touch.clientY;
        startWidth = wrapper.offsetWidth;
        startHeight = img.offsetHeight;
        aspectRatio = img.naturalWidth / img.naturalHeight;
        
        // Bring to front
        wrapper.style.zIndex = getMaxZIndex() + 1;
        
        e.stopPropagation();
      }, { passive: true });
      
      handle.addEventListener('touchmove', (e) => {
        if (!isResizing) return;
        
        const touch = e.touches[0];
        const deltaX = touch.clientX - startX;
        const deltaY = touch.clientY - startY;
        const delta = Math.max(deltaX, deltaY);
        
        let newWidth = startWidth + delta;
        newWidth = Math.max(100, Math.min(newWidth, window.innerWidth * 0.8));
        
        wrapper.style.width = newWidth + 'px';
        
        e.preventDefault();
      }, { passive: false });
      
      handle.addEventListener('touchend', () => {
        isResizing = false;
      }, { passive: true });
    }

    function getMaxZIndex() {
      let max = 0;
      document.querySelectorAll('.float-img').forEach(el => {
        const z = parseInt(el.style.zIndex) || 0;
        if (z > max) max = z;
      });
      return max;
    }

    function openLightbox(src) {
      // Save scroll position before opening lightbox
      savedScrollPosition = canvas.scrollTop;
      
      lightboxIndex = allPhotos.indexOf(src);
      if (lightboxIndex === -1) lightboxIndex = 0;
      
      lightboxImg.src = src;
      lightboxCurrent.textContent = String(lightboxIndex + 1).padStart(2, '0');
      lightboxTotal.textContent = String(allPhotos.length).padStart(2, '0');
      
      lightbox.classList.add('active');
      document.body.style.overflow = 'hidden';
      
      setTimeout(() => lightbox.classList.add('visible'), 10);
    }

    function closeLightbox() {
      lightbox.classList.remove('visible');
      setTimeout(() => {
        lightbox.classList.remove('active');
        document.body.style.overflow = '';
        
        // Restore scroll position
        if (savedScrollPosition > 0) {
          canvas.scrollTop = savedScrollPosition;
        }
      }, 400);
    }

    function navigateLightbox(dir) {
      lightboxIndex = (lightboxIndex + dir + allPhotos.length) % allPhotos.length;
      
      lightboxImg.style.opacity = '0';
      lightboxImg.style.transform = 'translateY(10px)';
      
      setTimeout(() => {
        lightboxImg.src = allPhotos[lightboxIndex];
        lightboxCurrent.textContent = String(lightboxIndex + 1).padStart(2, '0');
        lightboxImg.style.opacity = '1';
        lightboxImg.style.transform = 'translateY(0)';
      }, 200);
    }

    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    // Handle resize
    window.addEventListener('resize', () => {
      const wasMobile = isMobile;
      isMobile = window.innerWidth <= 768;
      
      if (wasMobile !== isMobile) {
        loadCategory(currentCategory);
      }
    });
  </script>
</body>
</html>